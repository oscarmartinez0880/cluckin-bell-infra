# Example: Complete Provider Configuration for k8s-controllers Module
#
# This example shows how to properly configure kubernetes and helm providers
# for use with the k8s-controllers module. Copy this file to your root module
# and customize as needed.
#
# USAGE:
# 1. Copy this file to your environment directory (e.g., stacks/environments/dev/providers.tf)
# 2. Update the cluster names and configuration to match your environment
# 3. Include the k8s-controllers module in your main.tf

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    helm = {
      source  = "hashicorp/helm"
      version = "~> 2.0"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.20"
    }
  }
}

# Example 1: Single Cluster Configuration (Most Common)
# Data sources to get EKS cluster connection information
data "aws_eks_cluster" "this" {
  name = var.cluster_name  # e.g., "cb-dev-use1"
}

data "aws_eks_cluster_auth" "this" {
  name = var.cluster_name
}

# Configure kubernetes provider for the cluster
provider "kubernetes" {
  host                   = data.aws_eks_cluster.this.endpoint
  cluster_ca_certificate = base64decode(data.aws_eks_cluster.this.certificate_authority[0].data)
  token                  = data.aws_eks_cluster_auth.this.token
}

# Configure helm provider for the cluster
provider "helm" {
  kubernetes {
    host                   = data.aws_eks_cluster.this.endpoint
    cluster_ca_certificate = base64decode(data.aws_eks_cluster.this.certificate_authority[0].data)
    token                  = data.aws_eks_cluster_auth.this.token
  }
}

# Use the k8s-controllers module (providers are automatically inherited)
module "k8s_controllers" {
  source = "../../modules/k8s-controllers"

  cluster_name = var.cluster_name
  environment  = var.environment
  aws_region   = var.aws_region
  vpc_id       = var.vpc_id

  # Enable controllers
  enable_aws_load_balancer_controller = true
  enable_cert_manager                 = true
  enable_external_dns                 = true

  # IRSA role ARNs (created by IRSA module)
  aws_load_balancer_controller_role_arn = var.aws_load_balancer_controller_role_arn
  cert_manager_role_arn                 = var.cert_manager_role_arn
  external_dns_role_arn                 = var.external_dns_role_arn

  # Configuration
  letsencrypt_email = var.letsencrypt_email
  domain_filter     = var.domain_filter
  zone_id_filters   = var.zone_id_filters
}

# Example 2: Multi-Cluster Configuration (Advanced)
# Uncomment and modify this section if you need to manage multiple clusters

/*
# DevQA cluster data sources
data "aws_eks_cluster" "devqa" {
  name = "cb-devqa-use1"
}

data "aws_eks_cluster_auth" "devqa" {
  name = "cb-devqa-use1"
}

# Production cluster data sources (cross-account)
data "aws_eks_cluster" "prod" {
  provider = aws.prod
  name     = "cb-prod-use1"
}

data "aws_eks_cluster_auth" "prod" {
  provider = aws.prod
  name     = "cb-prod-use1"
}

# DevQA cluster providers
provider "kubernetes" {
  alias = "devqa"
  
  host                   = data.aws_eks_cluster.devqa.endpoint
  cluster_ca_certificate = base64decode(data.aws_eks_cluster.devqa.certificate_authority[0].data)
  token                  = data.aws_eks_cluster_auth.devqa.token
}

provider "helm" {
  alias = "devqa"
  
  kubernetes {
    host                   = data.aws_eks_cluster.devqa.endpoint
    cluster_ca_certificate = base64decode(data.aws_eks_cluster.devqa.certificate_authority[0].data)
    token                  = data.aws_eks_cluster_auth.devqa.token
  }
}

# Production cluster providers (different account)
provider "kubernetes" {
  alias = "prod"
  
  host                   = data.aws_eks_cluster.prod.endpoint
  cluster_ca_certificate = base64decode(data.aws_eks_cluster.prod.certificate_authority[0].data)
  token                  = data.aws_eks_cluster_auth.prod.token
}

provider "helm" {
  alias = "prod"
  
  kubernetes {
    host                   = data.aws_eks_cluster.prod.endpoint
    cluster_ca_certificate = base64decode(data.aws_eks_cluster.prod.certificate_authority[0].data)
    token                  = data.aws_eks_cluster_auth.prod.token
  }
}

# DevQA k8s-controllers with explicit provider mapping
module "k8s_controllers_devqa" {
  source = "../../modules/k8s-controllers"
  
  providers = {
    kubernetes = kubernetes.devqa
    helm       = helm.devqa
  }

  cluster_name = "cb-devqa-use1"
  environment  = "devqa"
  aws_region   = "us-east-1"
  vpc_id       = var.devqa_vpc_id

  # DevQA configuration
  enable_aws_load_balancer_controller = true
  enable_cert_manager                 = true
  enable_external_dns                 = true

  aws_load_balancer_controller_role_arn = var.devqa_alb_controller_role_arn
  cert_manager_role_arn                 = var.devqa_cert_manager_role_arn
  external_dns_role_arn                 = var.devqa_external_dns_role_arn

  letsencrypt_email = "devops@cluckin-bell.com"
  domain_filter     = ""  # Empty for DevQA, rely on zone_id_filters
  zone_id_filters = [
    "Z2FDTNDATAQYW2",  # dev.cluckin-bell.com
    "Z3G5CAV3H4YUZ3"   # qa.cluckin-bell.com
  ]
}

# Production k8s-controllers with explicit provider mapping
module "k8s_controllers_prod" {
  source = "../../modules/k8s-controllers"
  
  providers = {
    kubernetes = kubernetes.prod
    helm       = helm.prod
  }

  cluster_name = "cb-prod-use1"
  environment  = "prod"
  aws_region   = "us-east-1"
  vpc_id       = var.prod_vpc_id

  # Production configuration
  enable_aws_load_balancer_controller = true
  enable_cert_manager                 = true
  enable_external_dns                 = true

  aws_load_balancer_controller_role_arn = var.prod_alb_controller_role_arn
  cert_manager_role_arn                 = var.prod_cert_manager_role_arn
  external_dns_role_arn                 = var.prod_external_dns_role_arn

  letsencrypt_email = "devops@cluckin-bell.com"
  domain_filter     = "cluckin-bell.com"
  zone_id_filters   = ["Z1D633PJN98FT9"]  # cluckin-bell.com zone
}
*/

# Example 3: Alternative Authentication Methods
# Uncomment and modify as needed for special authentication scenarios

/*
# Using exec plugin for AWS authentication
provider "kubernetes" {
  alias = "exec_auth"
  
  host                   = data.aws_eks_cluster.this.endpoint
  cluster_ca_certificate = base64decode(data.aws_eks_cluster.this.certificate_authority[0].data)
  
  exec {
    api_version = "client.authentication.k8s.io/v1beta1"
    command     = "aws"
    args = ["eks", "get-token", "--cluster-name", data.aws_eks_cluster.this.name]
  }
}

# Using assume role for cross-account access
provider "aws" {
  alias  = "prod_account"
  region = "us-east-1"
  
  assume_role {
    role_arn = "arn:aws:iam::987654321098:role/CrossAccountTerraformRole"
  }
}

data "aws_eks_cluster" "cross_account" {
  provider = aws.prod_account
  name     = "cb-prod-use1"
}

provider "kubernetes" {
  alias = "cross_account"
  
  host                   = data.aws_eks_cluster.cross_account.endpoint
  cluster_ca_certificate = base64decode(data.aws_eks_cluster.cross_account.certificate_authority[0].data)
  token                  = data.aws_eks_cluster_auth.cross_account.token
}
*/

# Required variables for this configuration
variable "cluster_name" {
  description = "Name of the EKS cluster"
  type        = string
}

variable "environment" {
  description = "Environment name (dev, qa, prod)"
  type        = string
}

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "vpc_id" {
  description = "VPC ID where the EKS cluster is deployed"
  type        = string
}

variable "aws_load_balancer_controller_role_arn" {
  description = "IAM role ARN for AWS Load Balancer Controller"
  type        = string
}

variable "cert_manager_role_arn" {
  description = "IAM role ARN for cert-manager"
  type        = string
}

variable "external_dns_role_arn" {
  description = "IAM role ARN for external-dns"
  type        = string
}

variable "letsencrypt_email" {
  description = "Email address for Let's Encrypt certificate registration"
  type        = string
}

variable "domain_filter" {
  description = "Domain filter for external-dns (empty for DevQA environments)"
  type        = string
  default     = ""
}

variable "zone_id_filters" {
  description = "List of Route53 zone IDs to manage (for external-dns)"
  type        = list(string)
  default     = []
}